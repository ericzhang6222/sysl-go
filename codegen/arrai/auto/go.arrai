let sysl = //{./sysl};

let name =
    let wordRE = //re.compile(`[\p{L}_][\p{L}\p{N}_]*`);
    let trimRE = //re.compile(`^_`).sub("");
    let initialisms = {
        # https://github.com/golang/lint/blob/8f45f776aaf18cebc8d65861cc70c33c60471952/lint.go#L771
        "ACL", "API", "ASCII", "CPU", "CSS", "DNS", "EOF", "GUID", "HTML",
        "HTTP", "HTTPS", "ID", "IP", "JSON", "LHS", "QPS", "RAM", "RHS", "RPC",
        "SLA", "SMTP", "SQL", "SSH", "TCP", "TLS", "TTL", "UDP", "UI", "UID",
        "UUID", "URI", "URL", "UTF8", "VM", "XML", "XMPP", "XSRF", "XSS",
    };
    \word
        let uppers = (wordRE.match(word) >> .(0)) >>> \i \v
            let upper = //str.upper(trimRE(v));
            cond {upper <: initialisms: upper, _: //str.title(v)};
        //seq.concat(uppers);

# Compute the Go type for a Sysl type. If leafOnly, then
let typeImpl = \leafOnly //fn.fix(\typeImpl \t
    let ptr = cond {t('opt')?:false && !({"sequence", "set"} & (t => .@)): "*"};
    let appname = cond {!leafOnly: cond t {
        {'typeRef': {'ref': {'appname': {'part': (a: [(s: appname), ...])}, ...}, ...}, ...}: appname,
        _: "",
    }};
    let typeName = cond t {
        {'attrs': {'sensitive': {'s': (s: "true")}, ...}, ...}: `common.SensitiveString`,
        {'primitive': p, ...}: cond p {
            (s: 'DECIMAL' ): `float64`,
            (s: 'INT'     ): `int64`,
            (s: 'FLOAT'   ): `float64`,
            (s: 'STRING'  ): `string`,
            (s: 'STRING_8'): `string`,
            (s: 'BOOL'    ): `bool`,
            (s: 'BYTES'   ): `[]byte`,
            (s: 'DATE'    ): `date.Date`,
            (s: 'DATETIME'): cond t {
                {'attrs': {'time_format': {'s': (s: "stdtime")}, ...}, ...}: `time.Time`,
                _: `convert.JSONTime`,
            },
        },
        {'sequence': sequence, ...}: $`[]${typeImpl(sequence)}`,
        {'set': set, ...}: $`${typeImpl(set)}Set`,
        {'typeRef': {'ref': {'path': (a: [(s: path)]), ...ref}, ...}, ...}:
            name(//seq.join(".", [appname, path] where .@item)),
        _: name(appname),
    };
    ptr ++ typeName
);

let type = typeImpl(false);
let leafType = typeImpl(true);

let varName = //re.compile(`_`).sub("");

let package = \app
    cond {
        'attrs' <: (app => .@):
            let attrs = app('attrs');
            cond attrs {
                {'go_package': {'s': (s: go_package)}, ...}: go_package,
                {'package': {'s': (s: package)}, ...}: //str.lower(package),
            },
    } || cond {
        'name' <: (app => .@):
            //str.lower($`${app('name')('part').a >> .s::}`),
        _: app,
    };

let pbPackage = \app
    {(
        alias: `pb`,
        package: $`${cond app('attrs') {
            {'go_pb_package': p, ...}: $`${p('s').s}`,
            _: '',
        }}`,
    )};

let typeWithPackage = \type \module
    cond type {
        [t]: name(t),
        [app, ...t]: $`${package(module('apps')(app))}.${t >> name(.)::.}`,
    };

let prelude = \app \imports $`
    // Code generated by sysl DO NOT EDIT.
    package ${package(app)}

    import (
        "context"
        "database/sql"
        "encoding/json"
        "flag"
        "fmt"
        "log"
        "net/http"
        "net/url"

        "github.com/anz-bank/sysl-go/catalogservice"
        "github.com/anz-bank/sysl-go/common"
        "github.com/anz-bank/sysl-go/core"
        "github.com/anz-bank/sysl-go/config"
        "github.com/anz-bank/sysl-go/convert"
        "github.com/anz-bank/sysl-go/database"
        "github.com/anz-bank/sysl-go/debug"
        "github.com/anz-bank/sysl-go/handlerinitialiser"
        "github.com/anz-bank/sysl-go/restlib"
        "github.com/anz-bank/sysl-go/validator"
        ${imports => cond . {(:alias, package: pkg): $`${alias} ${pkg:q}`, _: $`${.:q}`} orderby .::\i}

        "github.com/go-chi/chi"
        "github.com/rickb777/date"
        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
        "gopkg.in/yaml.v2"
    )`;

let methodName =
    # TODO: Remove these warts.
    let hasArg = //re.compile(`\{(\p{L}+)\}$`).match;
    let hasList = //re.compile(`[\p{L}\p{N}]$`).match; # TODO: Should be \[...\]
    \ep
        cond ep {
            {'restParams': {'method': (s: method), 'path': (s: path), ...r}, ...m}:
                let vars_in_url_name = "vars_in_url_name" <: sysl.patterns(ep);
                let withArg = cond {hasArg(path) && //str.upper(method) = "POST": "WithArg"};
                let getList = cond {hasList(path) && //str.upper(method) = "GET": "List"};
                let methodPostfix = //seq.split("/")(//seq.trim_prefix("/", path)) >>
                    let postfix = cond hasArg(.) {
                        [[_, arg]]: cond {vars_in_url_name: arg},
                        _: .,
                    };
                    //str.title(//str.lower(postfix));
                name(//str.title(//str.lower(method)) ++ $"${methodPostfix::}") ++ withArg ++ getList,
            {'name': (:s), ...}:
                name(s),
        };

let module = \module
    let typeWithClientPackage = \(:type, :seq, ...)
        let pkgnames = type => .@item;
        let packages = module('apps') where .@ <: pkgnames;
        cond {
            packages: $`${cond {seq: "[]"}}${package((packages single).@value)}.${name(type(1))}`,
            type = ["ok"]: "",
            _: $`${cond{seq: `[]`}}` ++ //str.title(//seq.concat(type)),
        };

    let targetApp = \target
        ((module('apps') where .@value('name') = target) single).@value;

    let methodSignature =
        let isError = //re.compile(`\berror\b`).match;
        \ep
            $`(ctx context.Context, req *${methodName(ep)}Request) ${
                let tn = sysl.endpoint.returns(ep) => .@item where .var != "error" => \t
                    # TODO: Remove double entry once cond array handling is fixed.
                    cond t.type {
                        ([""], [""]): "*http.Header",
                        _: $"*${typeWithClientPackage(t)}",
                    };
                cond tn {
                    {}: "error",
                    _: $`(${(tn orderby .) ++ ["error"]::, })`,
                }

            }`;

    let callSignature = \{'target': target, 'endpoint': ep, ...}
        let dep = targetApp(target);
        let package = package(dep);
        let ep = sysl.app.endpoint(dep, ep.s);
        let method = methodName(ep);
        let grpc = cond {'gRPC' <: sysl.patterns(dep): `, opts ...grpc.CallOption`};
        $`${name(package)}${method} func(ctx context.Context, req *${package}.${method}Request${grpc}) (${
            let typed = sysl.endpoint.normalReturns(ep) >> $`*${cond{.seq: `[]`}}${//seq.join(".", .type)}`;
            let untyped = sysl.endpoint.untypedReturns(ep) >> `*http.Header`;
            typed ++ untyped ++ ["error"]
        ::, })`;

    let clientDeps = \eps
        //rel.union(eps => \(@item: (@value: ep, ...), ...)
            sysl.endpoint.calls(ep) => \(@:_, @item: {'target': target, ...}) (
                :target,
                import: package(targetApp(target)),
                pbImport: pbPackage(targetApp(target)),
            ));

    let depField = \(:import, :target, ...)
        let grpc = 'gRPC' <: sysl.patterns(targetApp(target));
        (
            :grpc,
            name: $`${import}${name(import)}Service`,
            type: $`${import}.${cond {
                #grpc: $`${//str.title(target('part').a(0).s)}Client`,
                grpc: `Service`,
                _: `Service`,
            }}`,
        );

    (
        :callSignature,
        :clientDeps,
        :depField,
        :methodSignature,
        :targetApp,
        :typeWithClientPackage,
    );

(
    :methodName,
    :module,
    :name,
    :package,
    :pbPackage,
    :prelude,
    :type,
    :leafType,
    :typeWithPackage,
    :varName,
)
